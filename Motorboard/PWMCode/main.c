/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stm32f4xx.h>
#include <system_stm32f4xx.h>

//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
//  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif

void SystemClock_Config(void) {
	// Enable power clock
	RCC->APB1ENR |= RCC_APB1ENR_PWREN; // Enable the Power Control clock

	// Configure the voltage scaling
	PWR->CR &= ~PWR_CR_VOS; // Clear VOS bits
	PWR->CR |= PWR_CR_VOS_0; // Set VOS to scale 3 (1.2V)

    // Enable HSE
    RCC->CR |= RCC_CR_HSEON;
    while (!(RCC->CR & RCC_CR_HSERDY)); 		// Wait for HSE to be ready

    FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_LATENCY_2WS; // Enable prefetch and set latency

    // Configure PLL
    RCC->PLLCFGR = 0; // Clear PLL configuration register
    RCC->PLLCFGR |= (8 << RCC_PLLCFGR_PLLM_Pos)  // PLLM = 4
				 | (144 << RCC_PLLCFGR_PLLN_Pos)  // PLLN = 72
				 | (0 << RCC_PLLCFGR_PLLP_Pos)   // PLLP = 2 (bits 16 and 17)
				 | RCC_PLLCFGR_PLLSRC_HSE;       // PLL source = HSE

    // Enable PLL
    RCC->CR |= RCC_CR_PLLON;
    while (!(RCC->CR & RCC_CR_PLLRDY)); 	// Wait for PLL to be ready

    // Set PLL as the system clock source
    RCC->CFGR |= RCC_CFGR_SW_PLL;
    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);  // Wait for PLL to be used as system clock

    // Set the AHB and APB prescalers
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;  // AHB prescaler = 1 (HCLK = 72 MHz)
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV2; // APB1 prescaler = 2 (PCLK1 = 36 MHz)
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2; // APB2 prescaler = 2 (PCLK2 = 36 MHz)
}


void UART_Init(void) {

	RCC->APB1ENR |= RCC_APB1ENR_UART7EN;	// clock for uart7
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOFEN;	// clock for gpiof

	GPIOF->MODER &= ~(GPIO_MODER_MODER6 | GPIO_MODER_MODER7);	// clear bits
    GPIOF->MODER |= (GPIO_MODER_MODER6_1 | GPIO_MODER_MODER7_1);	// pins PA0 & PA1 to AF mode 0x2
    GPIOF->AFR[0] |= (8 << 28) | (8 << 24);  // Set AF8 (UART7)

    // baud rate with clk div 115200
    UART7->BRR = 0x138;

    // uart interrupts and enables
    UART7->CR1 = USART_CR1_UE | USART_CR1_TE | USART_CR1_RE | USART_CR1_RXNEIE;

    NVIC_SetPriority(UART7_IRQn, 1);
    NVIC_EnableIRQ(UART7_IRQn);
}

char tx_buf[3];
static char rx_buff[3];
static uint8_t rx_idx = 0;
static uint8_t idx = 0;
uint8_t flag = 0;


// make it take arrays
void sendStr(char msg[]) {
	memcpy(tx_buf,msg,sizeof(tx_buf));
	UART7->CR1 |= USART_CR1_TXEIE;				// enable interrupt when TX register is empty

}



void UART7_IRQHandler(void) {
	if (UART7->SR & USART_SR_RXNE) {			// receiving a string
		rx_buff[rx_idx] = UART7->DR;
		rx_idx++;

//		if (rx_idx >= sizeof(rx_buff)) {
//			rx_idx = 0;
//		}

		if (rx_idx == sizeof(rx_buff)) {
			rx_idx = 0;
			sendStr(rx_buff);
		}


	}
	if (UART7->SR & USART_SR_TXE) {				// transmitting a string buffer

		if (tx_buf[idx] != '\0') {
			UART7->DR = tx_buf[idx];
			idx++;
		}

		else {
			UART7->CR1 &= ~USART_CR1_TXEIE;
			idx = 0;
		}
	}
}



int main(void)
{

	SystemClock_Config();
	UART_Init();

	sendStr("ice\r\n");
//	for (volatile int i = 0; i < 10000000; i++);
//	sendStr("fire\r\n");

    /* Loop forever */
	for(;;) {

//		if (flag) {
////			sendStr(c);
//			tx_buf[0] = c;
//			tx_buf[1] = '\0';
//			UART7->CR1 |= USART_CR1_TXEIE;
//			flag = 0;
//		}
	}
}
